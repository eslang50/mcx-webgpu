(()=>{"use strict";const e="@group(0) @binding(0) var screen_sampler : sampler;\r\n@group(0) @binding(1) var color_buffer : texture_2d<f32>;\r\n\r\nstruct VertexOutput {\r\n    @builtin(position) Position : vec4<f32>,\r\n    @location(0) TexCoord : vec2<f32>,\r\n}\r\n\r\n@vertex\r\nfn vert_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\r\n\r\n    var positions = array<vec2<f32>, 6>(\r\n        vec2<f32>( 1.0,  1.0),\r\n        vec2<f32>( 1.0, -1.0),\r\n        vec2<f32>(-1.0, -1.0),\r\n        vec2<f32>( 1.0,  1.0),\r\n        vec2<f32>(-1.0, -1.0),\r\n        vec2<f32>(-1.0,  1.0)\r\n    );\r\n\r\n    var texCoords = array<vec2<f32>, 6>(\r\n        vec2<f32>(1.0, 0.0),\r\n        vec2<f32>(1.0, 1.0),\r\n        vec2<f32>(0.0, 1.0),\r\n        vec2<f32>(1.0, 0.0),\r\n        vec2<f32>(0.0, 1.0),\r\n        vec2<f32>(0.0, 0.0)\r\n    );\r\n\r\n    var output : VertexOutput;\r\n    output.Position = vec4<f32>(positions[VertexIndex], 0.0, 1.0);\r\n    output.TexCoord = texCoords[VertexIndex];\r\n    return output;\r\n}\r\n\r\n@fragment\r\nfn frag_main(@location(0) TexCoord : vec2<f32>) -> @location(0) vec4<f32> {\r\n  return textureSample(color_buffer, screen_sampler, TexCoord);\r\n}";var r=function(e,r,n,t){return new(n||(n=Promise))((function(i,o){function a(e){try{c(t.next(e))}catch(e){o(e)}}function s(e){try{c(t.throw(e))}catch(e){o(e)}}function c(e){var r;e.done?i(e.value):(r=e.value,r instanceof n?r:new n((function(e){e(r)}))).then(a,s)}c((t=t.apply(e,r||[])).next())}))};const n=document.getElementById("gfx-main"),t=new class{constructor(e){this.render=()=>{const e=this.device.createCommandEncoder(),r=e.beginComputePass();r.setPipeline(this.ray_tracing_pipeline),r.setBindGroup(0,this.ray_tracing_bind_group),r.dispatchWorkgroups(Math.floor((this.canvas.width+7)/8),Math.floor((this.canvas.height+7)/8),1),r.end();const n=this.context.getCurrentTexture().createView(),t=e.beginRenderPass({colorAttachments:[{view:n,clearValue:{r:.5,g:0,b:.25,a:1},loadOp:"clear",storeOp:"store"}]});t.setPipeline(this.screen_pipeline),t.setBindGroup(0,this.screen_bind_group),t.draw(6,1,0,0),t.end(),this.device.queue.submit([e.finish()]),requestAnimationFrame(this.render)},this.canvas=e}Initialize(){return r(this,void 0,void 0,(function*(){yield this.setupDevice(),yield this.createAssets(),yield this.makePipeline(),this.render()}))}setupDevice(){return r(this,void 0,void 0,(function*(){var e,r;this.adapter=yield null===(e=navigator.gpu)||void 0===e?void 0:e.requestAdapter(),this.device=yield null===(r=this.adapter)||void 0===r?void 0:r.requestDevice(),this.context=this.canvas.getContext("webgpu"),this.format="bgra8unorm",this.context.configure({device:this.device,format:this.format,alphaMode:"opaque"})}))}makePipeline(){return r(this,void 0,void 0,(function*(){const r=this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:"write-only",format:"rgba8unorm",viewDimension:"2d"}}]});this.ray_tracing_bind_group=this.device.createBindGroup({layout:r,entries:[{binding:0,resource:this.color_buffer_view}]});const n=this.device.createPipelineLayout({bindGroupLayouts:[r]});this.ray_tracing_pipeline=this.device.createComputePipeline({layout:n,compute:{module:this.device.createShaderModule({code:"@group(0) @binding(0) var color_buffer: texture_storage_2d<rgba8unorm, write>;\r\n\r\n\r\nstruct VoxelGridBuffer {\r\n    data: array<f32>\r\n};\r\n\r\nstruct Ray {\r\n    direction: vec3<f32>,\r\n    origin: vec3<f32>,\r\n}\r\n\r\n@group(0) @binding(0)\r\nvar<storage, read_write> voxelGrid: VoxelGridBuffer;\r\n\r\nconst GRID_SIZE: u32 = 100; // Combined size for all dimensions\r\nconst VOXEL_SIZE: f32 = 0.01; // voxel size\r\n\r\n\r\nfn getVoxelIndex(x: u32, y: u32, z: u32) -> u32 {\r\n  return (z * GRID_SIZE * GRID_SIZE) + (y * GRID_SIZE) + x;\r\n}\r\n\r\n@compute @workgroup_size(8,8,1)\r\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\r\n\r\n    initializeVoxelGrid();\r\n\r\n    let screen_size: vec2<i32> = vec2<i32>(textureDimensions(color_buffer));\r\n    let screen_pos : vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));\r\n\r\n    if (screen_pos.x >= screen_size.x || screen_pos.y >= screen_size.y) {\r\n        return;\r\n    }\r\n\r\n    for (var z: u32 = 0u; z < GRID_SIZE; z = z + 1u) {\r\n      for (var y: u32 = 0u; y < GRID_SIZE; y = y + 1u) {\r\n        for (var x: u32 = 0u; x < GRID_SIZE; x = x + 1u) {\r\n          let index = getVoxelIndex(x, y, z);\r\n          voxelGrid[index] = 0.0; \r\n          // later to support refraction/reflection\r\n        }\r\n      }\r\n    }\r\n\r\n    let initialPosition: vec3<f32> = vec3<f32>(0.0, 0.0, 0.0); \r\n    let initialDirection: vec3<f32> = vec3<f32>(0.0, 0.0, 1.0); \r\n\r\n    // initialize pencil beam\r\n\r\n    var pencilBeam: Ray;\r\n    pencilBeam.direction = normalize(initialDirection);\r\n    pencilBeam.origin = initialPosition;\r\n\r\n    let max_distance: f32 = 10.0; \r\n    let hit: bool = march(pencilBeam, max_distance);\r\n\r\n    if (hit) {\r\n        textureStore(color_buffer, screen_pos, vec4<f32>(1.0, 0.0, 0.0, 1.0)); // Red\r\n    } else {\r\n        textureStore(color_buffer, screen_pos, vec4<f32>(0.0, 0.0, 0.0, 1.0)); // Black\r\n    }\r\n\r\n    // add loop for hit function to traverse thru voxels\r\n    // detect whether cross voxel boundary based on scattering lens\r\n}\r\n\r\nfn march(ray: Ray, max_distance: f32) -> bool {\r\n  var current_position: vec3<f32> = ray.origin;\r\n  var distance_traveled: f32 = 0.0;\r\n\r\n  // Loop until reaching max distance or hitting a solid voxel\r\n  while (distance_traveled < max_distance) {\r\n    // Get the index of the voxel at the current position\r\n    let voxel_index: u32 = getVoxelIndex(\r\n      u32(current_position.x / VOXEL_SIZE),\r\n      u32(current_position.y / VOXEL_SIZE),\r\n      u32(current_position.z / VOXEL_SIZE)\r\n    );\r\n\r\n    // Access the material value of the current voxel\r\n    let material_value: f32 = voxelGrid[voxel_index];\r\n\r\n    // Check if the voxel is solid (material value > threshold)\r\n    if (material_value > 0.5) { \r\n      return true; // Intersection found \r\n    }\r\n\r\n    // Move to the next voxel along the ray direction\r\n    let step_size: f32 = min(voxel_size, max_distance - distance_traveled);\r\n    current_position += ray.direction * step_size;\r\n    distance_traveled += step_size;\r\n  }\r\n  // No intersection found within the maximum distance\r\n  return false;\r\n}\r\n\r\n"}),entryPoint:"main"}});const t=this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,sampler:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{}}]});this.screen_bind_group=this.device.createBindGroup({layout:t,entries:[{binding:0,resource:this.sampler},{binding:1,resource:this.color_buffer_view}]});const i=this.device.createPipelineLayout({bindGroupLayouts:[t]});this.screen_pipeline=this.device.createRenderPipeline({layout:i,vertex:{module:this.device.createShaderModule({code:e}),entryPoint:"vert_main"},fragment:{module:this.device.createShaderModule({code:e}),entryPoint:"frag_main",targets:[{format:"bgra8unorm"}]},primitive:{topology:"triangle-list"}})}))}createAssets(){return r(this,void 0,void 0,(function*(){this.color_buffer=this.device.createTexture({size:{width:this.canvas.width,height:this.canvas.height},format:"rgba8unorm",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING}),this.color_buffer_view=this.color_buffer.createView(),this.sampler=this.device.createSampler({addressModeU:"repeat",addressModeV:"repeat",magFilter:"linear",minFilter:"nearest",mipmapFilter:"nearest",maxAnisotropy:1})}))}}(n);t.Initialize()})();